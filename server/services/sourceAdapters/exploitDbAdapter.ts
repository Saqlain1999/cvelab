import { BaseSourceAdapter } from './baseSourceAdapter';
import { RawCveData, CveDiscoveryOptions } from '../multiSourceCveDiscoveryService';

/**
 * Enhanced Exploit Database Adapter - Integrates with exploit-db.com for CVE discovery
 * Not just PoCs, but comprehensive CVE discovery from exploit database
 */
export class ExploitDbAdapter extends BaseSourceAdapter {
  readonly sourceName = 'exploitdb';
  readonly displayName = 'Exploit Database';
  readonly baseUrl = 'https://www.exploit-db.com';
  readonly reliabilityScore = 0.70; // Good source but focused on exploitable CVEs

  private readonly searchApiUrl = 'https://www.exploit-db.com/api/v1';
  private readonly csvDataUrl = 'https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv';

  constructor() {
    super();
    // Exploit-DB specific configuration
    this.config.maxResultsPerPage = 100;
    this.rateLimitState.maxRequests = 50; // Conservative for scraping
  }

  public supportsHistoricalData(): boolean {
    return true; // Excellent historical coverage of exploitable CVEs
  }

  public supportsRealTimeUpdates(): boolean {
    return true; // Updated regularly with new exploits
  }

  public getMaxTimeframeYears(): number {
    return 20; // Good historical coverage
  }

  public async discoverCves(options: CveDiscoveryOptions): Promise<RawCveData[]> {
    console.log(`Exploit-DB: Starting CVE discovery with ${options.timeframeYears} year timeframe`);
    
    const allCves: RawCveData[] = [];
    
    try {
      // Primary approach: Use CSV data download for comprehensive coverage
      const csvCves = await this.discoverFromCsvData(options);
      allCves.push(...csvCves);

      // Secondary approach: Search API for specific queries
      if (options.technologies && options.technologies.length > 0) {
        for (const technology of options.technologies.slice(0, 3)) {
          try {
            const techCves = await this.searchByTechnology(technology, options);
            allCves.push(...techCves);
            await this.delay(2000); // Respect rate limits
          } catch (error) {
            console.warn(`Exploit-DB: Failed to search for technology ${technology}:`, error);
          }
        }
      }

      // Search by keywords if provided
      if (options.keywords && options.keywords.length > 0) {
        for (const keyword of options.keywords.slice(0, 2)) {
          try {
            const keywordCves = await this.searchByKeyword(keyword, options);
            allCves.push(...keywordCves);
            await this.delay(2000);
          } catch (error) {
            console.warn(`Exploit-DB: Failed to search for keyword ${keyword}:`, error);
          }
        }
      }

      console.log(`Exploit-DB: Discovered ${allCves.length} CVEs`);
      return this.deduplicateAndFilterResults(allCves, options);

    } catch (error) {
      console.error('Exploit-DB: Discovery failed:', error);
      return [];
    }
  }

  public async getCveDetails(cveId: string): Promise<RawCveData | null> {
    try {
      console.log(`Exploit-DB: Fetching details for ${cveId}`);
      
      // Search for the specific CVE
      const searchUrl = `${this.searchApiUrl}/search`;
      const requestBody = {
        cve: cveId
      };

      const response = await this.makeReliableRequest(searchUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`Exploit-DB API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      if (data.data && Array.isArray(data.data) && data.data.length > 0) {
        // Take the first matching result
        return this.transformExploitDbEntry(data.data[0]);
      }

      return null;

    } catch (error) {
      console.error(`Exploit-DB: Failed to get details for ${cveId}:`, error);
      return null;
    }
  }

  protected async performHealthCheck(): Promise<boolean> {
    try {
      const response = await this.makeReliableRequest(`${this.baseUrl}/`);
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }

  private async discoverFromCsvData(options: CveDiscoveryOptions): Promise<RawCveData[]> {
    try {
      console.log('Exploit-DB: Fetching CSV data for comprehensive CVE discovery');
      
      const response = await this.makeReliableRequest(this.csvDataUrl);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch CSV data: ${response.status}`);
      }

      const csvText = await response.text();
      return this.parseCsvForCves(csvText, options);

    } catch (error) {
      console.error('Exploit-DB: Failed to fetch CSV data:', error);
      return [];
    }
  }

  private parseCsvForCves(csvText: string, options: CveDiscoveryOptions): RawCveData[] {
    const cves: RawCveData[] = [];
    
    try {
      const lines = csvText.split('\n');
      const header = lines[0];
      
      // Expected CSV columns: id,file,description,date,author,type,platform,port,cve
      const cveColumnIndex = header.toLowerCase().split(',').findIndex(col => col.includes('cve'));
      const descColumnIndex = header.toLowerCase().split(',').findIndex(col => col.includes('description'));
      const dateColumnIndex = header.toLowerCase().split(',').findIndex(col => col.includes('date'));
      const typeColumnIndex = header.toLowerCase().split(',').findIndex(col => col.includes('type'));
      const platformColumnIndex = header.toLowerCase().split(',').findIndex(col => col.includes('platform'));
      const authorColumnIndex = header.toLowerCase().split(',').findIndex(col => col.includes('author'));
      const idColumnIndex = 0; // First column is usually ID

      console.log(`Exploit-DB: Parsing CSV with ${lines.length} lines`);

      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        try {
          const columns = this.parseCsvLine(line);
          
          if (columns.length < Math.max(cveColumnIndex, descColumnIndex, dateColumnIndex) + 1) {
            continue; // Skip malformed lines
          }

          const cveField = columns[cveColumnIndex] || '';
          const cveIds = this.extractCveIds(cveField);
          
          if (cveIds.length === 0) continue; // Skip entries without CVE IDs

          const description = columns[descColumnIndex] || 'No description available';
          const dateStr = columns[dateColumnIndex] || '';
          const type = columns[typeColumnIndex] || 'unknown';
          const platform = columns[platformColumnIndex] || '';
          const author = columns[authorColumnIndex] || '';
          const exploitId = columns[idColumnIndex] || '';

          // Create CVE entries for each CVE ID found
          for (const cveId of cveIds) {
            // Filter by timeframe
            const publishedDate = this.parseDate(dateStr);
            if (!this.isWithinTimeframe(publishedDate, options.timeframeYears)) {
              continue;
            }

            const cve: RawCveData = {
              cveId: cveId,
              source: this.sourceName,
              sourceUrl: `${this.baseUrl}/exploits/${exploitId}`,
              description: this.cleanDescription(description),
              publishedDate: publishedDate || new Date(),
              lastModifiedDate: publishedDate || new Date(),
              severity: this.inferSeverityFromType(type),
              affectedProducts: platform ? [platform] : undefined,
              sourceMetadata: {
                exploitDbId: exploitId,
                exploitType: type,
                exploitPlatform: platform,
                exploitAuthor: author,
                hasPublicExploit: true,
                extractionSource: 'csv_data',
                extractionDate: new Date().toISOString()
              },
              rawData: {
                csvRow: columns,
                exploitDbEntry: true
              }
            };

            cves.push(cve);
          }

        } catch (error) {
          console.warn(`Exploit-DB: Failed to parse CSV line ${i}:`, error);
          continue;
        }
      }

      console.log(`Exploit-DB: Extracted ${cves.length} CVEs from CSV data`);
      return cves;

    } catch (error) {
      console.error('Exploit-DB: Failed to parse CSV data:', error);
      return [];
    }
  }

  private async searchByTechnology(technology: string, options: CveDiscoveryOptions): Promise<RawCveData[]> {
    try {
      const searchUrl = `${this.searchApiUrl}/search`;
      const requestBody = {
        text: technology,
        type: 'papers', // Include papers and exploits
        platform: technology.toLowerCase()
      };

      const response = await this.makeReliableRequest(searchUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`Exploit-DB API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      if (data.data && Array.isArray(data.data)) {
        const cves: RawCveData[] = [];
        
        for (const entry of data.data.slice(0, 50)) { // Limit results
          const entryCves = this.extractCveIdsFromEntry(entry);
          for (const cveId of entryCves) {
            const cve = this.transformExploitDbEntry(entry, cveId);
            if (this.isWithinTimeframe(cve.publishedDate, options.timeframeYears)) {
              cves.push(cve);
            }
          }
        }
        
        console.log(`Exploit-DB: Found ${cves.length} CVEs for technology ${technology}`);
        return cves;
      }

      return [];

    } catch (error) {
      console.error(`Exploit-DB: Technology search failed for ${technology}:`, error);
      return [];
    }
  }

  private async searchByKeyword(keyword: string, options: CveDiscoveryOptions): Promise<RawCveData[]> {
    try {
      const searchUrl = `${this.searchApiUrl}/search`;
      const requestBody = {
        text: keyword
      };

      const response = await this.makeReliableRequest(searchUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`Exploit-DB API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      if (data.data && Array.isArray(data.data)) {
        const cves: RawCveData[] = [];
        
        for (const entry of data.data.slice(0, 30)) { // Limit keyword results
          const entryCves = this.extractCveIdsFromEntry(entry);
          for (const cveId of entryCves) {
            const cve = this.transformExploitDbEntry(entry, cveId);
            if (this.isWithinTimeframe(cve.publishedDate, options.timeframeYears)) {
              cves.push(cve);
            }
          }
        }
        
        console.log(`Exploit-DB: Found ${cves.length} CVEs for keyword ${keyword}`);
        return cves;
      }

      return [];

    } catch (error) {
      console.error(`Exploit-DB: Keyword search failed for ${keyword}:`, error);
      return [];
    }
  }

  private transformExploitDbEntry(entry: any, specificCveId?: string): RawCveData {
    // Extract CVE IDs from entry
    const cveIds = specificCveId ? [specificCveId] : this.extractCveIdsFromEntry(entry);
    const primaryCveId = cveIds[0] || 'UNKNOWN';

    const cve: RawCveData = {
      cveId: primaryCveId,
      source: this.sourceName,
      sourceUrl: `${this.baseUrl}/exploits/${entry.id || entry.edb_id}`,
      description: this.cleanDescription(entry.description || entry.title || 'No description available'),
      publishedDate: this.parseDate(entry.date_published || entry.date),
      lastModifiedDate: this.parseDate(entry.date_published || entry.date),
      severity: this.inferSeverityFromType(entry.type),
      affectedProducts: entry.platform ? [entry.platform] : undefined,
      references: this.extractReferencesFromEntry(entry),
      sourceMetadata: {
        exploitDbId: entry.id || entry.edb_id,
        exploitType: entry.type,
        exploitPlatform: entry.platform,
        exploitAuthor: entry.author,
        hasPublicExploit: true,
        allCveIds: cveIds,
        extractionDate: new Date().toISOString(),
        verificationStatus: entry.verified || false
      },
      rawData: {
        exploitDbEntry: entry
      }
    };

    return cve;
  }

  // Helper methods
  private extractCveIds(text: string): string[] {
    const cvePattern = /CVE-\d{4}-\d{4,}/gi;
    const matches = text.match(cvePattern);
    return matches ? Array.from(new Set(matches.map(id => id.toUpperCase()))) : [];
  }

  private extractCveIdsFromEntry(entry: any): string[] {
    const searchFields = [
      entry.description,
      entry.title,
      entry.tags,
      entry.cve,
      JSON.stringify(entry)
    ].filter(Boolean);

    const allCveIds: string[] = [];
    for (const field of searchFields) {
      const cveIds = this.extractCveIds(String(field));
      allCveIds.push(...cveIds);
    }

    return Array.from(new Set(allCveIds));
  }

  private extractReferencesFromEntry(entry: any): string[] {
    const references: string[] = [];
    
    if (entry.references) {
      if (Array.isArray(entry.references)) {
        references.push(...entry.references);
      } else if (typeof entry.references === 'string') {
        // Extract URLs from reference string
        const urlPattern = /https?:\/\/[^\s]+/g;
        const urls = entry.references.match(urlPattern);
        if (urls) references.push(...urls);
      }
    }

    // Add Exploit-DB URL
    if (entry.id || entry.edb_id) {
      references.push(`${this.baseUrl}/exploits/${entry.id || entry.edb_id}`);
    }

    return Array.from(new Set(references));
  }

  private parseCsvLine(line: string): string[] {
    // Simple CSV parsing that handles quoted fields
    const result: string[] = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(current.trim());
        current = '';
      } else {
        current += char;
      }
    }
    
    result.push(current.trim());
    return result;
  }

  private inferSeverityFromType(type: string): string {
    const typeStr = (type || '').toLowerCase();
    
    if (typeStr.includes('remote') || typeStr.includes('rce')) return 'HIGH';
    if (typeStr.includes('privilege') || typeStr.includes('escalation')) return 'HIGH';
    if (typeStr.includes('buffer') || typeStr.includes('overflow')) return 'HIGH';
    if (typeStr.includes('injection') || typeStr.includes('sql')) return 'MEDIUM';
    if (typeStr.includes('xss') || typeStr.includes('csrf')) return 'MEDIUM';
    if (typeStr.includes('dos') || typeStr.includes('denial')) return 'MEDIUM';
    if (typeStr.includes('info') || typeStr.includes('disclosure')) return 'LOW';
    
    return 'MEDIUM'; // Default for exploitable vulnerabilities
  }

  private isWithinTimeframe(date: Date, timeframeYears: number): boolean {
    const cutoffDate = new Date();
    cutoffDate.setFullYear(cutoffDate.getFullYear() - timeframeYears);
    return date >= cutoffDate;
  }

  private deduplicateAndFilterResults(cves: RawCveData[], options: CveDiscoveryOptions): RawCveData[] {
    // Deduplicate by CVE ID
    const seen = new Set<string>();
    const deduplicated: RawCveData[] = [];
    
    for (const cve of cves) {
      if (!seen.has(cve.cveId)) {
        seen.add(cve.cveId);
        deduplicated.push(cve);
      }
    }

    // Apply filters
    let filtered = deduplicated;

    if (options.severities && options.severities.length > 0) {
      filtered = filtered.filter(cve => 
        options.severities!.includes(cve.severity)
      );
    }

    // Limit results
    const maxResults = options.maxResultsPerSource || 500;
    return filtered.slice(0, maxResults);
  }

}